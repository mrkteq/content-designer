<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Mark Tucker - Content Designer. Portfolio showcasing process, rationale, and execution in content design.">
  <meta name="color-scheme" content="light dark">
  <link rel="icon" href="/favicon.ico" sizes="32x32">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="manifest" href="/site.webmanifest">
  <title>Mark Tucker | Content Designer</title>
  <style>
    /* Reset and Base */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --color-text: #1a1a1a;
      --color-text-secondary: #525252;
      --color-background: #ffffff;
      --color-surface: #f5f5f5;
      --color-border: #e0e0e0;
      --color-accent: #0066cc;
      --color-accent-hover: #004999;
      --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      --font-mono: ui-monospace, "Cascadia Code", "Source Code Pro", Menlo, Consolas, monospace;
      --max-width: 680px;
      --space-xs: 0.5rem;
      --space-sm: 1rem;
      --space-md: 1.5rem;
      --space-lg: 2.5rem;
      --space-xl: 4rem;
      --transition-fast: 150ms ease-out;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --color-text: #e8e8e8;
        --color-text-secondary: #a0a0a0;
        --color-background: #121212;
        --color-surface: #1e1e1e;
        --color-border: #333333;
        --color-accent: #4d9fff;
        --color-accent-hover: #80b8ff;
      }
    }

    html {
      scroll-behavior: smooth;
      scroll-padding-top: 5rem;
    }

    body {
      font-family: var(--font-sans);
      font-size: 1rem;
      line-height: 1.6;
      color: var(--color-text);
      background-color: var(--color-background);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    @media (max-width: 480px) {
      body {
        font-size: 0.9375rem;
        line-height: 1.5;
      }
    }

    /* Skip Link */
    .skip-link {
      position: absolute;
      top: -100%;
      left: 0;
      padding: var(--space-sm);
      background: var(--color-accent);
      color: #ffffff;
      text-decoration: none;
      z-index: 1000;
    }

    .skip-link:focus {
      top: 0;
    }

    /* Typography */
    h1, h2, h3, h4 {
      line-height: 1.3;
      font-weight: 600;
    }

    h1 {
      font-size: 1.75rem;
    }

    @media (max-width: 480px) {
      h1 {
        font-size: 1.5rem;
      }
    }

    h2 {
      font-size: 1.5rem;
      margin-bottom: var(--space-md);
    }

    @media (max-width: 480px) {
      h2 {
        font-size: 1.25rem;
      }
    }

    h3 {
      font-size: 1.125rem;
      margin-bottom: var(--space-sm);
    }

    @media (max-width: 480px) {
      h3 {
        font-size: 1rem;
      }
    }

    h4 {
      font-size: 0.875rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--color-text-secondary);
      margin-bottom: var(--space-xs);
    }

    p {
      margin-bottom: var(--space-sm);
    }

    p:last-child {
      margin-bottom: 0;
    }

    a {
      color: var(--color-accent);
      text-decoration: underline;
      text-underline-offset: 2px;
      transition: color var(--transition-fast);
    }

    a:hover {
      color: var(--color-accent-hover);
    }

    a:focus-visible {
      outline: 2px solid var(--color-accent);
      outline-offset: 2px;
    }

    ul {
      margin-left: var(--space-md);
    }

    /* Layout */
    .container {
      max-width: var(--max-width);
      margin: 0 auto;
      padding: 0 var(--space-md);
    }

    @media (max-width: 480px) {
      .container {
        padding: 0 var(--space-sm);
      }
    }

    /* Header */
    .site-header {
      padding: var(--space-md) 0;
      border-bottom: 1px solid var(--color-border);
      background: var(--color-background);
    }

    @media (min-width: 1025px) {
      .site-header {
        position: sticky;
        top: 0;
        z-index: 100;
      }
    }

    .header-content {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
    }

    @media (min-width: 640px) {
      .header-content {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }
    }

    @media (max-width: 480px) {
      .header-content {
        gap: var(--space-xs);
      }
    }

    .site-title {
      font-size: 1.125rem;
      font-weight: 600;
    }

    @media (max-width: 480px) {
      .site-title {
        font-size: 1rem;
      }
    }

    .site-title span {
      color: var(--color-text-secondary);
      font-weight: 400;
    }

    /* Navigation */
    .site-nav ul {
      list-style: none;
      display: flex;
      gap: var(--space-md);
      flex-wrap: wrap;
    }

    @media (max-width: 480px) {
      .site-nav ul {
        gap: var(--space-sm);
        font-size: 0.875rem;
      }
    }

    .site-nav a {
      color: var(--color-text-secondary);
      text-decoration: none;
      font-size: 0.9375rem;
      padding: var(--space-xs) 0;
      border-bottom: 2px solid transparent;
      transition: color var(--transition-fast), border-color var(--transition-fast);
    }

    .site-nav a:hover,
    .site-nav a:focus-visible {
      color: var(--color-text);
      border-bottom-color: var(--color-accent);
    }

    /* Main Content */
    main {
      padding: var(--space-lg) 0;
    }

    @media (max-width: 480px) {
      main {
        padding: var(--space-md) 0;
      }
    }

    section {
      margin-bottom: var(--space-xl);
    }

    @media (max-width: 480px) {
      section {
        margin-bottom: var(--space-lg);
      }
    }

    section:last-of-type {
      margin-bottom: 0;
    }

    /* Introduction */
    .intro {
      font-size: 1.125rem;
    }

    /* Case Studies */
    .case-studies {
      display: flex;
      flex-direction: column;
      gap: var(--space-xl);
    }

    .case-study {
      border-top: 1px solid var(--color-border);
      padding-top: var(--space-lg);
    }

    .case-study-title {
      margin-bottom: var(--space-lg);
    }

    .case-study-section {
      margin-bottom: var(--space-lg);
    }

    .case-study-section:last-child {
      margin-bottom: 0;
    }

    /* Artifact Display */
    .artifact {
      background: var(--color-surface);
      border: 1px solid var(--color-border);
      border-radius: 4px;
      margin: var(--space-md) 0;
    }

    .artifact summary {
      padding: var(--space-sm) var(--space-md);
      cursor: pointer;
      font-weight: 500;
      list-style: none;
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .artifact summary::-webkit-details-marker {
      display: none;
    }

    .artifact summary::before {
      content: "";
      width: 0;
      height: 0;
      border-top: 0.5em solid transparent;
      border-bottom: 0.5em solid transparent;
      border-left: 0.75em solid currentColor;
      transition: transform var(--transition-fast);
    }
    .artifact[open] summary::before {
      transform: rotate(90deg);
    }

    .artifact summary:hover {
      background: var(--color-border);
    }

    .artifact summary:focus-visible {
      outline: 2px solid var(--color-accent);
      outline-offset: -2px;
    }

    .artifact-content {
      padding: var(--space-md);
      border-top: 1px solid var(--color-border);
      max-height: 400px;
      overflow-y: auto;
      font-size: 0.875rem;
    }

    .artifact-content pre {
      font-family: var(--font-mono);
      font-size: 0.875rem;
      line-height: 1.5;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-x: auto;
    }

    @media (max-width: 480px) {
      .artifact-content {
        max-height: 300px;
        padding: var(--space-sm);
      }

      .artifact-content pre {
        font-size: 0.8125rem;
      }
    }

    /* Side-by-side artifacts */
    .artifact-pair {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    @media (min-width: 640px) {
      .artifact-pair {
        flex-direction: row;
        margin: var(--space-md);
      }

      .artifact-pair .artifact {
        flex: 1;
        margin: 0;
      }
    }

    /* Placeholder styling */
    .placeholder {
      color: var(--color-text-secondary);
      font-style: italic;
    }

    /* Contact */
    .contact-info {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
    }

    .contact-item {
      display: flex;
      gap: var(--space-sm);
    }

    .contact-label {
      color: var(--color-text-secondary);
      min-width: 5rem;
    }

    /* Footer */
    .site-footer {
      padding: var(--space-lg) 0;
      border-top: 1px solid var(--color-border);
      color: var(--color-text-secondary);
      font-size: 0.875rem;
    }

    /* Print Styles */
    @media print {
      .site-header {
        position: static;
      }

      .site-nav,
      .artifact summary::before {
        display: none;
      }

      .artifact {
        break-inside: avoid;
      }

      .artifact[open] .artifact-content {
        max-height: none;
        overflow: visible;
      }

      a {
        color: var(--color-text);
      }

      a[href^="http"]::after {
        content: " (" attr(href) ")";
        font-size: 0.75rem;
        color: var(--color-text-secondary);
      }
    }

    /* Focus visible for better keyboard UX */
    :focus-visible {
      outline: 2px solid var(--color-accent);
      outline-offset: 2px;
    }

    /* Reduce motion for users who prefer it */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    /* Selection */
    ::selection {
      background: var(--color-accent);
      color: #ffffff;
    }
  </style>
</head>
<body>
  <a href="#main" class="skip-link">Skip to main content</a>

  <header class="site-header">
    <div class="container header-content">
      <h1 class="site-title">Mark Tucker <span>Content Designer</span></h1>
      <nav class="site-nav" aria-label="Main navigation">
        <ul>
          <li><a href="#introduction">Introduction</a></li>
          <li><a href="#case-studies">Case Studies</a></li>
          <li><a href="#contact">Contact</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <main id="main" class="container">
    <section id="introduction" aria-labelledby="intro-heading">
      <h2 id="intro-heading">Introduction</h2>
      <div class="intro">
        <p class="placeholder">I design content that reduces cognitive load and enables clear action.</p>
        <p class="placeholder">My background is in front-end development, where I learned that structure determines usability. The best interface fails if the words confuse. The clearest writing fails if the structure fights the reader.</p>
        <p class="placeholder">I approach content design as systems work. Users exist in variable states, different contexts, different capacities, different goals. Content must meet them where they are, not where we assume they should be. This means deliberate decisions about structure, format, language, and timing.</p>
        <p class="placeholder">The case studies below demonstrate my process: identifying user needs, researching constraints, making explicit content decisions, and measuring outcomes. Each artifact began as a functional document solving a real problem. The surrounding narrative explains why I made the choices I made.</p>
        <p class="placeholder">I am based in Málaga, Spain, available for remote work across UK and EU time zones.</p>
      </div>
    </section>

    <section id="case-studies" aria-labelledby="case-studies-heading">
      <h2 id="case-studies-heading">Case Studies</h2>
      <div class="case-studies">

        <article class="case-study">
          <h3 class="case-study-title">Capacity-Aware Content Design</h3>

          <div class="case-study-section">
            <h4>Context</h4>
            <p class="placeholder">Productivity systems assume consistent user capacity. They provide the same interface, the same information density, and the same decision requirements regardless of user state. For users experiencing variable cognitive capacity, whether from fatigue, illness, stress, or neurodivergent patterns, this mismatch causes system abandonment or harmful forcing (attempting complex tasks while impaired).</p>
            <p class="placeholder">I needed a personal operational system that acknowledged capacity variation as a permanent constraint, not a temporary problem to overcome. The system had to function when I could not make good decisions about what the system should tell me to do.</p>
          </div>

          <div class="case-study-section">
            <h4>Discovery</h4>
            <p class="placeholder">Through systematic self observation over several months, I identified four distinct capacity states with reliable indicators:</p>
            <ul class="placeholder">
              <li><strong>High</strong>: Clear thinking, 2+ hour focus possible, complex problem solving accessible</li>
              <li><strong>Medium</strong>: Functional but effortful, 30-60 minute focus blocks, simple tasks manageable</li>
              <li><strong>Low</strong>: Significant effort for simple tasks, 10-20 minute bursts maximum, decision making impaired</li>
              <li><strong>Depleted</strong>: Cannot focus on work, physical exhaustion present, requires complete rest</li>
            </ul>
            <p class="placeholder">Each state had predictable duration patterns and optimal activity types. Critically, the transition between states was often invisible to the user experiencing it, I would attempt high capacity work while actually in a low capacity state, producing poor output and accelerating depletion.</p>
            <p class="placeholder">The core user need: a system that makes capacity appropriate decisions for me when I cannot reliably make them myself.</p>
          </div>

          <div class="case-study-section">
            <h4>Content Decisions</h4>
            <p class="placeholder"><strong>State classification with behavioral indicators</strong>. Users cannot assess their own capacity through introspection alone. I provided observable, testable indicators: "Can I focus on complex technical work for 2 hours?" is answerable. "Am I at high capacity?" is not. The content forces self assessment through concrete questions rather than abstract self rating.
            <p class="placeholder"><strong>Activity-to-capacity mapping as lookup table</strong>. When capacity is compromised, users cannot process prose efficiently. I structured the activity mapping as a scannable table with clear categories: "High Capacity Required," "Medium Capacity Sufficient," "Low Capacity Sufficient." The user identifies their state, then looks up permitted activities. No interpretation required.</p>
            <p class="placeholder"><strong>Directive language, not advisory</strong>. The document uses "Do NOT attempt" rather than "Consider avoiding." When a user is in a low capacity state, hedged language creates decision load. Directive framing removes ambiguity. The user follows instructions rather than weighing options.</p>
            <p class="placeholder"><strong>Forcing functions as pre-flight checklist</strong>. The "Capacity Override Prevention" section exists because users in degraded states will rationalise forcing. The content explicitly names this pattern and provides a hard rule: "Never force high capacity work at low capacity." Naming the failure mode reduces its occurrence.</p>
            <p class="placeholder"><strong>Burnout warning signs as pattern matching list</strong>. Users in early burnout cannot recognise it through self assessment. I provided external indicators: "Low capacity 3+ consecutive days," "Consistent inability to meet daily minimums." The content enables recognition through pattern matching rather than self diagnosis.</p>
          </div>

          <details class="artifact">
            <summary>View Artifact: Final Content Specification</summary>
            <div class="artifact-content">
              <pre># Cognitive Capacity Routing Specification

## Purpose

Define decision protocols for routing tasks based on current cognitive capacity, preventing burnout while maintaining forward progress.

## Capacity State Classification

### High Capacity
**Indicators**:
- Clear thinking, normal energy
- Can focus for 2+ hours consecutively
- Complex problem-solving feels manageable
- No brain fog or confusion

**Duration Typical**: 2-4 hours (usually morning)

**Optimal Activities**:
- JavaScript learning (Eloquent JavaScript chapters)
- Portfolio project building (3-5 hour projects)
- Technical interview preparation
- Complex problem-solving (debugging, architecture decisions)
- Resume optimization (STAR bullets, ATS formatting)

### Medium Capacity
**Indicators**:
- Functional but effort required
- Focus limited to 30-60 minute blocks
- Simple tasks feel manageable, complex tasks feel overwhelming
- Mild mental fatigue present

**Duration Typical**: 4-6 hours (usually midday to afternoon)

**Optimal Activities**:
- Freelance platform bidding (repetitive, low complexity)
- Job application submission (templated, customization limited)
- Portfolio site updates (administrative, not creative)
- Documentation (STAR bullets for completed projects)
- Code review of own work (not building new features)

### Low Capacity
**Indicators**:
- Significant effort required for simple tasks
- Focus limited to 10-20 minute bursts
- Decision-making impaired
- Strong desire to rest or distract

**Duration Typical**: Variable (usually late afternoon/evening or entire day if exhausted)

**Optimal Activities**:
- Testing deployment URLs (mechanical, no decision-making)
- Planning next day's tasks (low cognitive load)
- LifeOS Inbox processing (classification only, no execution)
- Passive learning (reading, not coding)
- Rest (preferred option if capacity very low)

### Depleted Capacity
**Indicators**:
- Cannot focus on work tasks
- Physical exhaustion present
- Decision-making severely impaired
- Strong resistance to any productive activity

**Duration Typical**: Variable (recovery required)

**Optimal Activity**:
- Complete rest, no work activities
- Resume work next day at natural capacity level

## Routing Decision Tree

```
Wake up
↓
Assess capacity
↓
High? → Execute morning block (technical work)
Medium? → Execute afternoon block (bids/applications)
Low? → Execute evening block (documentation) OR rest
Depleted? → Rest entirely, resume tomorrow
```

## Daily Capacity Assessment Protocol

### Morning Assessment (9:00 AM)

Ask:
1. Can I focus on complex technical work for 2 hours?
2. Does reading code feel manageable or overwhelming?
3. Can I explain technical concepts clearly?

**Yes to all 3** → High capacity, execute morning block
**Yes to 1-2** → Medium capacity, start with afternoon block
**No to all** → Low capacity, start with evening block or rest

### Midday Reassessment (12:00 PM)

If started at high capacity:
- Capacity maintained? → Continue technical work
- Capacity declined to medium? → Switch to afternoon block
- Capacity declined to low? → Switch to evening block or rest

If started at medium capacity:
- Capacity increased? → Attempt technical work (small task only)
- Capacity maintained? → Continue afternoon block
- Capacity declined to low? → Switch to evening block or rest

### Evening Assessment (16:00 PM)

- Can still perform administrative tasks? → Continue evening block
- Cannot focus on any work? → End day, rest

## Activity-to-Capacity Mapping

### High Capacity Required
- JavaScript chapter work (Eloquent JavaScript)
- Building new portfolio projects
- Debugging complex issues
- Technical interview preparation
- Architecture decisions

**Do NOT attempt these at medium or low capacity** (quality suffers, frustration increases)

### Medium Capacity Sufficient
- Freelance platform bidding (10 daily minimum)
- Job application submission (5 daily minimum)
- Portfolio site administrative updates
- Writing STAR bullets for completed work
- Reviewing and responding to messages

**Can be performed at high capacity** (but reserves high capacity for suboptimal tasks)

### Low Capacity Sufficient
- Testing deployment URLs
- Planning next day (simple task list)
- LifeOS Inbox classification
- Passive reading (no active coding)
- Documentation organization

**Should NOT be performed at high or medium capacity** (waste of higher capacity)

### No Capacity Required
- Complete rest
- Sleep
- Non-work activities

## Forcing Functions

### Capacity Override Prevention

**Never force high-capacity work at low capacity**
Consequences:
- Low-quality output
- Frustration and burnout risk
- Time wasted (work must be redone)
- Capacity depletion accelerated

If deadline pressure exists:
1. Reduce scope of work instead of forcing capacity
2. Break work into smaller chunks executable at current capacity
3. Defer to next high-capacity period (usually next morning)

### Minimum Viable Daily Progress

**High capacity days**: Complete all daily minimums + technical work
**Medium capacity days**: Complete daily minimums (bids + applications)
**Low capacity days**: Complete simplified minimums (5 bids, 2 applications) OR rest
**Depleted capacity days**: Rest entirely

Do NOT attempt to "catch up" by forcing work at low capacity.

## Pattern Recognition

### Capacity Trends (Track Weekly)

Monitor for patterns:
- High capacity mostly mornings? → Schedule all technical work morning block
- Capacity crashes after lunch? → Front-load critical work before noon
- Low capacity 3+ consecutive days? → Burnout warning, increase rest

Adjust daily schedule based on observed patterns.

### Burnout Prevention

**Warning signs**:
- Low capacity 3+ consecutive days
- Consistent inability to meet daily minimums
- Physical symptoms (headaches, exhaustion, sleep disruption)
- Emotional resistance to all work activities

**Intervention** (if 2+ warning signs present):
1. Reduce daily minimums by 50%
2. Eliminate technical work for 3 days (maintenance activities only)
3. Increase sleep and rest periods
4. Resume full schedule only when capacity returns to normal

## Capacity-Based Planning

### Project Assignment

Before starting any work session:
1. Assess current capacity (high/medium/low)
2. Consult activity-to-capacity mapping
3. Select appropriate work from that category
4. Execute until capacity declines or block ends
5. Reassess capacity before next block

### Weekly Planning

Sunday evening:
- Review previous week's capacity patterns
- Identify highest-capacity periods (usually mornings)
- Schedule technical work (JavaScript, portfolio building) during those periods
- Schedule lower-capacity work (bids, applications) during medium periods
- Leave low-capacity periods flexible (documentation or rest)

## Success Metrics

Capacity routing is effective when:
- Technical work consistently completed at high capacity
- Daily minimums met 5+ days per week without forcing
- Burnout symptoms absent
- Weekly progress maintained without exhaustion
- Work quality consistent across tasks

## Failure Conditions

Capacity routing has failed if:
- Consistently forcing work at insufficient capacity
- Burnout symptoms present 3+ consecutive days
- Work quality declining despite effort
- Daily minimums missed 3+ consecutive days
- Physical or emotional exhaustion persistent

Recovery protocol: Reduce all commitments by 50%, rest until capacity returns, resume gradually.
</pre>
            </div>
          </details>

          <div class="case-study-section">
            <h4>Outcome</h4>
            <p class="placeholder">The system enabled sustained execution across 30+ day periods without burnout recurrence. Capacity appropriate task routing eliminated wasted effort on mismatched work. The explicit "Depleted" state with permission to rest completely removed guilt driven forcing that previously accelerated depletion cycles.</p>
            <p class="placeholder">The document has been revised twice based on observed failures, each revision tightening language or adding forcing functions where the original content permitted workarounds.</p>
          </div>
        </article>

        <article class="case-study">
          <h3 class="case-study-title">Format Adaptation for Different Use Cases</h3>

          <div class="case-study-section">
            <h4>Context</h4>
            <p class="placeholder">Problem solving methodologies exist in books, courses, and frameworks. They are typically comprehensive and optimised for learning, not for use at moment of need. A user facing an immediate problem cannot process a 200 page methodology. They need the right tool, now, with minimal decision overhead.</p>
            <p class="placeholder">I had synthesised problem solving approaches from multiple sources into a comprehensive reference document. The document was thorough and well structured. It was also useless when I actually had a problem to solve, because accessing the relevant section required cognitive capacity I did not have while stuck.</p>
          </div>

          <div class="case-study-section">
            <h4>Discovery</h4>
            <p class="placeholder">I identified two distinct use cases for the same underlying content:</p>
            <p class="placeholder"><strong>Learning/Reference Use Case</strong>: User has time and capacity. Goal is understanding the full system, building mental models, internalising principles. Comprehensive coverage appropriate. User reads linearly or explores systematically.</p>
            <p class="placeholder"><strong>Active Problem Solving Use Case</strong>: User is stuck, possibly frustrated, capacity partially consumed by the problem itself. Goal is selecting and applying one tool immediately. Comprehensive coverage is obstacle. User needs fastest path to appropriate action.</p>
            <p class="placeholder">The same content cannot serve both use cases optimally. Format and structure must adapt to user state and intent.</p>
          </div>

          <div class="case-study-section">
            <h4>Content Decisions</h4>
            <p class="placeholder"><strong>Two separate documents, not one document with sections</strong>. I initially considered a single document with "quick reference" and "full reference" sections. Testing revealed this failed, users in the active problem solving state still encountered the comprehensive content and got pulled into reading rather than acting. Physical separation into two files enforced the boundary.</p>
            <p class="placeholder"><strong>Situation-to-diagram routing as primary structure (quick version)</strong>. The quick reference opens with "Situation-to-Diagram Quick Reference" a lookup table mapping problem states to diagram types. User identifies their situation, receives tool recommendation, follows numbered steps. No preamble, no principles, no context. Action first.</p>
            <p class="placeholder"><strong>Principles and theory retained only in comprehensive version</strong>. The full document includes "Core Principles," "Cognitive State Routing Protocol," and detailed methodology. This content aids learning and supports deliberate practice. It is excluded entirely from the quick reference, not summarized, not linked, absent.</p>
            <p class="placeholder"><strong>Numbered steps, maximum 5 per tool</strong>. Each diagram type in the quick reference includes only the essential creation steps. "Box-and-Arrow Diagram" has four steps. If a tool requires more than five steps, it is either too complex for quick reference or needs decomposition.</p>
            <p class="placeholder"><strong>Red flags section in both versions with identical content</strong>. Both documents include the same "Red Flags" section: "Stop if time on tool exceeds time on problem" and "Analysis continues 3+ days without action." This content is critical regardless of use case and appears in both without modification.</p>
          </div>

          <div class="artifact-pair">
            <details class="artifact">
              <summary>View Artifact: Format A</summary>
              <div class="artifact-content">
                <pre># Diagrams

## Purpose

Systematic approach to visual thinking through diagrams. Maps cognitive states to appropriate diagram types with step-by-step creation guides.

## Cognitive State Routing Protocol

### State Classification
```
Cannot articulate problem → CONFUSED → Box-and-Arrow Diagram
Know problem, unclear cause → STUCK → Why-Why-Why Analysis (5-Layer)
Multiple validated options → DECISION → Two-Column Consequence List or Weighted Matrix
```

### Cognitive Capacity Assessment

**High Capacity** (clear thinking, normal energy):
- Use full diagram creation process
- Generate multiple options
- Systematic analysis

**Medium Capacity** (functional but impaired):
- Use simplified diagram versions
- Limit to 3 options maximum
- Single-pass analysis only

**Low Capacity** (compromised thinking, low energy):
- Skip to action without diagram
- Use previous decisions/templates
- Defer complex analysis to higher capacity state

## Core Principles

- Externalization precedes solution
- Root cause vs. symptom
- Start simple, add complexity only when needed
- Diagrams counter VUCA forces: Stability, Transparency, Understanding, Clarity, Kindness

## Mandatory Tools (Use in Order)

### 1. Box-and-Arrow Diagram
**When**: Cannot explain problem clearly

**Process**:
1. Draw rectangle for each entity involved
2. Draw arrows showing relationships
3. Label all shapes and arrows explicitly
4. Write problem statement in one sentence

**Termination**: Problem can be articulated clearly

### 2. Why-Why-Why Analysis (5-Layer)
**When**: Problem clear, cause unknown

**Process**:
1. Write problem statement
2. Ask "Why is this happening?" → Record answer (Layer 1)
3. Ask "Why does that happen?" → Record answer (Layer 2)
4. Repeat for Layers 3-5
5. At Layer 5, validate: "If I fix this, does original problem disappear?"

**Depth Guide**:
- Layers 1-2: Observable symptoms
- Layers 3-4: Behavior patterns
- Layer 5: Root cause (structural/foundational)

### 3. Two-Column Consequence List
**When**: Binary choice with significant consequences

**Process**:
1. Draw vertical line down center
2. Write Option A and Option B at top
3. List all consequences in respective columns
4. Circle worst-case consequence in each column
5. Select option whose worst-case is acceptable

## Enhancement Tools (Add Only When Mandatory Tools Fail)

### Logic Tree
**When**: Single why-chain insufficient (3+ independent causes)

### Weighted Decision Matrix
**When**: 3+ options AND 5+ criteria

### Process Flow Diagram
**When**: Sequential steps need mapping

### Swimlane Diagram
**When**: Multiple actors cause confusion

## Four-Step Problem-Solving Process

### Step 1: Understand Current Situation
- Define problem in one clear sentence
- Specify goal: What (measurable), When (deadline), How (constraints)
- Test: Can you measure success?

### Step 2: Identify Root Cause
- Use Why-Why-Why Analysis to reach Layer 5
- If multiple causes, use Logic Tree
- Validate with data, not assumptions
- Test: If you fix this cause, does original problem disappear?

### Step 3: Develop Action Plan
- List minimum 5 solution options
- Evaluate feasibility
- Select hypothesis solution
- Define success metrics BEFORE execution
- Set review checkpoint

### Step 4: Execute and Iterate
- Execute planned action
- Measure outcome against predefined criteria
- Review at scheduled checkpoint
- If unsuccessful: Return to Step 2 or 3
- If successful: Document solution pattern

## Implementation Rules

### Forcing Functions (Pre-Action Checklist)
Before action, verify:
1. Problem externalized (diagram/written)
2. Root cause identified (not symptom)
3. Minimum 5 options generated
4. Success measurement defined
5. Review point scheduled

If any answer is NO: Stop. Complete that step.

### Red Flags (Over-Complication)
Abort if:
- Time on diagram exceeds time on problem
- Analysis continues 3+ days without action
- Creating overhead that prevents execution

### Cognitive Capacity Routing

**High Capacity**:
- Full diagram creation
- Multiple iterations
- Comprehensive analysis

**Medium Capacity**:
- Simplified diagrams only
- Single iteration
- 3 options maximum
- 30-minute time limit per diagram

**Low Capacity**:
- Skip diagram creation
- Use template from previous decision
- Execute based on prior pattern
- Defer complex analysis to high capacity state

## Minimum Viable Problem-Solving

For any problem:
1. Write problem in one sentence
2. Draw it or list causes (box-and-arrow or Why-Why-Why)
3. Identify most fixable cause
4. Execute one action today
5. Check tomorrow if action helped

Cycle time: 24 hours maximum from problem identification to first action.

## Anti-Patterns (Failure Modes)

| Failure | Detection | Fix |
|---------|-----------|-----|
| Solution jumping | Action before cause analysis | Force Why-Why-Why first |
| Analysis paralysis | No decision after 3 days | Set 30-min timer, decide with available data |
| Vague goals | Cannot measure success | Apply What/When/How test |
| Complexity overwhelm | Cannot articulate problem | Create box-and-arrow diagram |

## Diagram Construction Rules

**Start simple**:
- Basic shapes (rectangles, circles, diamonds)
- Lines for connections
- Clear labels on everything
- Nothing decorative in first iteration

**Be consistent**:
- Same shape for same type of element
- Same arrow style for same type of relationship

**Iterate**:
- First version will be incomplete
- Expect 2-3 refinements
- Each iteration adds clarity

## Sources

Watanabe, K. (2007). *Problem Solving 101: A Simple Book for Smart People.* Portfolio/Penguin.

Covert, A. (2022). *Stuck? Diagrams Help.* Self-published.
</pre>
              </div>
            </details>

            <details class="artifact">
              <summary>View Artifact: Format B</summary>
              <div class="artifact-content">
                <pre># Diagrams (Quick)

## Purpose

Quick-reference guide for diagram selection and creation. Condensed from comprehensive problem-solving frameworks.

## Core Principles

- Externalization before solution
- Root cause vs symptom
- Start simple
- Diagrams counter VUCA: Stability, Transparency, Understanding, Clarity, Kindness

## Situation-to-Diagram Quick Reference

### Problem Clarification

**Cannot explain problem** → Box-and-Arrow Diagram
1. Draw rectangles for entities
2. Draw arrows for relationships
3. Label everything
4. Write problem statement in one sentence

**Know problem, unclear cause** → Why-Why-Why Analysis (5-Layer)
1. Write problem
2. Ask "Why?" 5 times
3. Layer 5 = root cause
4. Test: If fixed, does problem disappear?

**Multiple simultaneous causes** → Logic Tree
1. Problem at trunk
2. Branch into MECE categories
3. Sub-branch to specific causes
4. Mark yes/no based on data

### Decision-Making

**Binary choice** → Two-Column Consequence List
1. Divide page vertically
2. List consequences for each option
3. Circle worst-case in each column
4. Select acceptable worst-case

**3+ options, 5+ criteria** → Weighted Decision Matrix
1. List criteria (assign weights: H=3x, M=2x, L=1x)
2. Score each option (1-5 scale)
3. Multiply score by weight
4. Sum totals, highest wins

**Sequential decisions** → Decision Tree
1. Draw branches for each choice
2. Continue branching to end states
3. Work backward to evaluate optimal path

### Planning and Process

**Sequential steps** → Process Flow Diagram
1. Rectangle for each step
2. Arrows showing flow
3. Diamond for decisions
4. Label all elements

**Multiple actors** → Swimlane Diagram
1. Horizontal lanes per actor
2. Steps in appropriate lanes
3. Arrows across lanes show handoffs

**Timeline with dependencies** → Gantt Chart
1. Tasks down left column
2. Time scale across top
3. Bars showing duration
4. Arrows showing dependencies

**Long-term phases** → Roadmap
1. Horizontal timeline
2. Major phases as segments
3. Milestones as points
4. Key activities under phases

### Creative Thinking

**Generating ideas** → Mind Map
1. Central concept in middle
2. Main branches radiating outward
3. Sub-branches from each main branch
4. Continue until ideas stop
5. Connect related items across branches

**Breaking mental block** → Random Connection Matrix
1. List problem elements (5-10)
2. List random words (5-10)
3. Force connection in each grid cell
4. Develop promising connections

**Concept overlap** → Venn Diagram
1. Circle per concept (2-4 maximum)
2. Overlap where shared attributes
3. Unique attributes in non-overlapping sections
4. Shared attributes in overlap

### Relationship and Structure

**Network of connections** → Network Diagram
1. Node for each entity
2. Lines between connected nodes
3. Vary thickness for strength (optional)
4. Observe clusters and hubs

**Hierarchical structure** → Hierarchy Diagram
1. Highest level at top
2. Children below parents
3. Consistent horizontal alignment per level
4. One parent per item

**Sequence of events** → Timeline
1. Horizontal line for time span
2. Mark scale intervals
3. Events as points along line
4. Vertical markers at event points

**State changes** → State Diagram
1. Circle for each state
2. Arrows for valid transitions
3. Label arrows with triggers
4. Mark initial and final states

## Tool Selection Priority

**Start here**:
1. Box-and-arrow (problem unclear)
2. Why-Why-Why (problem clear, cause unknown)
3. Two-column list (binary decision)

**Add complexity only when**:
- Single why-chain fails → Logic tree
- 3+ options and 5+ criteria → Weighted matrix
- Process involves handoffs → Swimlane
- Time dependencies matter → Gantt/Timeline

## Four-Step Problem-Solving Process

1. **Define situation**: Problem in one sentence, goal (What/When/How)
2. **Identify root cause**: Why-Why-Why to Layer 5 or Logic Tree
3. **Develop action plan**: Minimum 5 options, select best, define success metrics
4. **Execute and iterate**: Take action, measure, review, adjust

## Minimum Viable Practice

For any problem:
1. Write problem in one sentence
2. Draw it or list causes
3. Identify most fixable cause
4. Execute one action today
5. Check tomorrow if action helped

Cycle time: 24 hours maximum.

## Red Flags

Stop if:
- Time on tool exceeds time on problem
- Analysis continues 3+ days without action
- Asking "which diagram?" instead of starting

## Diagram Construction

- Basic shapes only (rectangles, circles, diamonds)
- Lines for connections
- Labels on everything
- Nothing decorative
- Expect 2-3 iterations

## Sources

Watanabe, K. (2007). *Problem Solving 101*
Covert, A. (2022). *Stuck? Diagrams Help*
</pre>
              </div>
            </details>
          </div>

          <div class="case-study-section">
            <h4>Outcome</h4>
            <p class="placeholder">The paired documents enabled appropriate tool selection within 60 seconds during active problem solving, versus 10+ minutes of searching through comprehensive reference. The comprehensive version remained valuable for periodic review and methodology refinement, serving its intended learning purpose without compromise.</p>
            <p class="placeholder">Usage pattern confirmed the split: quick reference accessed during work sessions, comprehensive version accessed during weekly review periods.</p>
          </div>
        </article>

        <article class="case-study">
          <h3 class="case-study-title">Protocol and Guideline Design</h3>

          <div class="case-study-section">
            <h4>Context</h4>
            <p class="placeholder">AI coding assistants (Claude, ChatGPT, Copilot) offer significant productivity gains but create dependency risk. Users accept generated code without comprehension. Debugging becomes impossible without AI assistance. The tool that accelerates learning simultaneously prevents it.</p>
            <p class="placeholder">I needed a protocol governing my own AI assistant usage that captured productivity benefits while preventing dependency formation. The protocol had to be specific enough to constrain behavior, flexible enough for varied situations, and honest about the tradeoffs involved.</p>
          </div>

          <div class="case-study-section">
            <h4>Discovery</h4>
            <p class="placeholder">Through observation of my own AI pairing sessions, I identified failure patterns:</p>
            <ul class="placeholder">
              <li><strong>Comprehension skip</strong>: Accepting code without reading it fully, discovered later when debugging fails</li>
              <li><strong>Complexity creep</strong>: Requesting features beyond current understanding, creating unmaintainable code</li>
              <li><strong>Prompt laziness</strong>: Requesting complete solutions rather than guidance, eliminating learning</li>
              <li><strong>Dependency formation</strong>: Inability to write equivalent code without AI assistance after extended AI-assisted period</li>
            </ul>
            <p class="placeholder">The core tension: AI assistance is most valuable when users are least capable of evaluating its output. The protocol must be most restrictive precisely when users are most tempted to ignore restrictions.</p>
          </div>

          <div class="case-study-section">
            <h4>Content Decisions</h4>
            <p class="placeholder"><strong>Comprehension-First Protocol as binding rules, not suggestions</strong>. The document opens with three non-negotiable rules: "Understand Before Deploy," "Complexity Threshold," "Incremental Building." Framing as protocol rather than guidelines signals that these are constraints, not preferences. Users cannot rationalise exceptions to protocols as easily as they can ignore suggestions.</p>
            <p class="placeholder"><strong>Explicit prohibited patterns</strong>. Rather than only describing good behavior, I enumerated bad behavior explicitly: "Do NOT request complete applications in single prompt," "Do NOT accept code without explanation." Prohibition lists are more memorable and recognizable than aspiration lists. Users can pattern match their own behavior against prohibited actions.</p>
            <p class="placeholder"><strong>Quality control checklist as gate</strong>. Before accepting any AI generated code, users must verify: "Every line understood," "Can explain what code does," "Tested in browser successfully," "Could recreate similar solution independently." The checklist is a forcing function, if any item is unchecked, the user cannot proceed. This moves the decision from willpower to process.</p>
            <p class="placeholder"><strong>Warning signs of over reliance as self diagnostic</strong>. I included explicit indicators of dependency formation: "Copying code without reading," "Unable to debug AI generated code," "Skipping comprehension in favor of speed." Users in early dependency cannot recognise it through self assessment. The list enables recognition through behavioural pattern matching.</p>
            <p class="placeholder"><strong>Mandatory manual work as structural prevention</strong>. The protocol requires that every project include "at least one feature built entirely without AI assistance." This is not a suggestion, it is a structural requirement. Dependency cannot form if the protocol enforces regular unassisted work.</p>
            <p class="placeholder"><strong>Failure conditions with explicit stop criteria</strong>. The document ends with conditions requiring immediate cessation of AI assistance: "Cannot explain code in own words," "Multiple unexplained bugs in AI generated code." These are not warnings, they are stop conditions. When triggered, the user must build equivalent functionality manually before resuming AI usage.</p>
          </div>

          <details class="artifact">
            <summary>View Artifact: Protocol Document Excerpt</summary>
            <div class="artifact-content">
              <pre># AI Pairing

## Purpose

Define protocols for using AI assistants (Claude, ChatGPT) as coding partners while maintaining comprehension and avoiding dependency.

## Binding Constraints

- Cannot steer complex LLM-generated implementations without full comprehension
- Must understand every line of code before deployment
- Build complexity threshold: 3-5 hours per project
- Current capability: vanilla JavaScript, HTML/CSS, basic tooling

## Comprehension-First Protocol

### Rule 1: Understand Before Deploy

Every line of AI-generated code must be:
1. Read completely
2. Understood functionally
3. Explained aloud or in writing
4. Verified through testing

If any line is unclear: request explanation or simplification before proceeding.

### Rule 2: Complexity Threshold

AI-generated solutions must not exceed current comprehension capacity:
- **Acceptable**: Vanilla JavaScript, modern CSS, HTML5 features
- **Requires explanation**: Array methods, promises, async/await
- **Reject immediately**: Complex state management, advanced patterns, frameworks before mastery

If solution complexity exceeds threshold: request simpler implementation.

### Rule 3: Incremental Building

Request code in small chunks:
1. Single feature per request
2. 20-50 lines maximum per response
3. Test each chunk before requesting next
4. Build understanding progressively

Do NOT request complete applications in single prompt.

## Effective Prompting Patterns

### Project Initialization
```
I'm building a [project type] using vanilla JavaScript, HTML5, and CSS3.
I need to create [specific feature].
Keep the implementation simple and use only ES6+ JavaScript.
Explain any array methods or modern syntax used.
Provide code in chunks of 20-50 lines maximum.
```

### Feature Implementation
```
I need to add [specific feature] to my existing code.
Here is my current implementation: [paste relevant code]
Keep the solution simple and consistent with my existing code style.
Explain your approach before providing code.
```

### Debugging
```
This code is producing [specific error or unexpected behavior]: [paste code]
Expected behavior: [describe]
Actual behavior: [describe]
Help me understand what's wrong and how to fix it.
Explain the root cause before providing the fix.
```

### Code Review
```
Review this code for: [paste code]
1. Functionality correctness
2. Modern best practices
3. Potential bugs
4. Simplification opportunities

Explain any issues found and suggest improvements.
```

## Prohibited Prompting Patterns

### Do NOT Request

- "Build me a complete [application]" (too large, no understanding)
- "Make this perfect" (vague, no learning)
- "Use best practices" (assumes knowledge not present)
- "Add all features" (scope creep, complexity explosion)
- "Optimize this" without specifying what/why (premature optimization)

### Do NOT Accept Blindly

- Code without explanation
- Solutions using unfamiliar patterns
- Implementations exceeding 50 lines without breakdown
- Suggestions to use libraries/frameworks before vanilla mastery
- Refactoring that obscures logic

## Learning Integration

### After Each AI Interaction

1. **Document understanding**: Write comment explaining what code does
2. **Test thoroughly**: Verify functionality in browser
3. **Experiment**: Modify code to see what breaks
4. **Internalize pattern**: Could you recreate this without AI?

If answer to step 4 is NO: request further explanation or simplification.

### Building Mental Models

For each new concept AI introduces:
1. Create standalone example demonstrating concept
2. Add to personal reference notes
3. Build variation without AI assistance
4. Teach concept to rubber duck or write explanation

## AI Tool Selection

### Claude (Preferred for)
- Longer explanations
- Step-by-step breakdowns
- Code review and debugging
- Conceptual understanding

### ChatGPT (Alternative for)
- Quick syntax lookups
- Boilerplate generation
- Rapid iteration on small features

### GitHub Copilot (Not Recommended)
- Inline suggestions reduce active thinking
- Encourages code acceptance without understanding
- Skip until vanilla JavaScript mastery achieved

## Quality Control Checklist

Before accepting AI-generated code:
- [ ] Every line understood
- [ ] Can explain what code does
- [ ] Tested in browser successfully
- [ ] No complexity beyond current capability
- [ ] Could recreate similar solution independently
- [ ] Code matches project style/patterns

If any item unchecked: request clarification or simplification.

## Dependency Prevention

### Warning Signs of Over-Reliance

- Copying code without reading
- Accepting solutions without testing
- Requesting complete features instead of guidance
- Unable to debug AI-generated code
- Skipping comprehension in favor of speed

If 2+ warning signs present: stop using AI, build next feature manually.

### Mandatory Manual Work

Every project must include:
- At least 1 feature built entirely without AI assistance
- Debugging session without AI help
- Code refactoring based on own analysis

This prevents dependency and builds independent capability.

## Project-Specific Protocols

### Portfolio Projects (Week 1-4)
- AI assistance permitted for: syntax, modern CSS features, fetch API patterns
- Mandatory manual work: DOM manipulation, event handling, basic logic
- Comprehension requirement: Explain entire codebase to rubber duck

### JavaScript Practice (Eloquent JavaScript)
- AI assistance for: Concept clarification, syntax questions, debugging specific errors
- Mandatory manual work: All chapter exercises, projects from scratch
- Comprehension requirement: Build each chapter project without AI before moving forward

### Resume Projects
- AI assistance permitted for: README writing, deployment documentation
- Mandatory manual work: All code implementation, testing, debugging

## Failure Conditions

Stop using AI assistance immediately if:
- Cannot explain code in own words
- Multiple unexplained bugs in AI-generated code
- Project complexity exceeds understanding
- Debugging becomes impossible without AI
- Speed prioritized over learning

Resume AI usage only after building equivalent feature manually.

## Success Metrics

AI assistance is effective when:
- Comprehension maintained for 100% of codebase
- Can recreate features without AI assistance
- Debugging capability increases over time
- Learning new concepts, not just copying code
- Project complexity stays within skill threshold
</pre>
            </div>
          </details>

          <div class="case-study-section">
            <h4>Outcome</h4>
            <p class="placeholder">The protocol enabled sustained AI assisted development across multiple projects without dependency formation. Manual work requirements maintained independent capability. Comprehension first rules prevented accumulation of unmaintainable code.</p>
            <p class="placeholder">The protocol has been revised once to strengthen the "Complexity Threshold" section after an incident where accepted code exceeded debugging capability.</p>
          </div>
        </article>

      </div>
    </section>

    <section id="contact" aria-labelledby="contact-heading">
      <h2 id="contact-heading">Contact</h2>
      <div class="contact-info">
        <div class="contact-item">
          <span class="contact-label">Email</span>
          <a href="mailto:markanthonytucker@gmail.com">markanthonytucker@gmail.com</a>
        </div>
        <div class="contact-item">
          <span class="contact-label">LinkedIn</span>
          <a href="https://linkedin.com/in/username">linkedin.com/in/mark-anthony-tucker</a>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container">
      <p>&copy; 2026 Mark Tucker</p>
    </div>
  </footer>
</body>
</html>